window.app = window.app || {}

# Entire application facade class.
# Implements common application functionality.
class ApplicationFacade

  # @constructor
  # @param {Object} appScope Application scope
  # @param {Object} gon GON object wich received from Rails controlelr action
  constructor: (appScope, gon) ->
    @appScope = appScope
    @gon      = gon

    @viewCallbacks =

      # Simple function wich generates a toast message based on GON data.
      # Activaets at any URL.
      generateToast: =>
        unless @gon.flash.type is 'none'
          switch @gon.flash.type
            when 'notice'
              iqwerty.toast.Toast "NOTICE: #{@gon.flash.message}"
            when 'alert'
              messageList = []
              for msgTitle of gon.flash.message
                messageList.push "ALERT: #{msgTitle} #{@gon.flash.message[msgTitle]}"
              iqwerty.toast.Toast messageList.join('<br>')

      # Simple stock form visibility toggler.
      # Activates on /portfolios/:id action.
      stockFormToggle: -> $('#stock-form-cell').slideToggle()

      # Click handler which will generate progress blocks due to graphics generating (passed in params).
      #
      # @param {Function} generateGraphicsCallback Your graphics callback generator (but can by any other function).
      clickForGraphiczGenerating: (generateGraphicsCallback) ->
        symbols = []
        $('tr.is-selected').map (elem, value) ->
          symbols.push $(value).data().symbol

        if symbols.length > 0
          $('#portfolio-chart').html('
            <div class="mdl-progress
                        mdl-js-progress
                        mdl-progress__indeterminate"
                 style="display: inline-block; width: 50%">
            </div>
          ')
          componentHandler.upgradeAllRegistered()
          generateGraphicsCallback(symbols)
        else
          $('#portfolio-chart').html('
            <div style="display: inline-block; text-align: center; font-size: 14px; font-weight: bold;">
              <i class="material-icons" style="vertical-align: middle">error</i> SELECT STOCKS!
            </div>
          ')

  # Portfolio object generator.
  #
  # @returns {Object} Portfolio class instance.
  initializePortfolio: ->
    new @appScope.Portfolio(
      @gon.portfolio.title,
      @gon.portfolio.stocks.map((stock) -> { symbol: stock.symbol, count: stock.count })
    )

  # Generates array of query generators.
  #
  # @param {Array} symbols Array of stock symbols.
  # @returns {Array} Array of YahooFinance API URL generators (generated by based on YFAPIRequestBuilder)
  initializeQueryGenerators: (symbols) ->
    queryGenerators = []
    for symb in symbols
      queryGenerators.push ( new @appScope.YFAPIRequestBuilder).buildQueryGenerator([symb])
    return queryGenerators

  # Generates an anonimous function. Works as clojure (scoped fetched data and converted data).
  # Returned function works as fetching done function in AJAX context.
  # This function will:
  #   1) counts fetched data (as a counter);
  #   2) converts fetched data to the readable form (for Portfolio.costHistory method);
  #   3) will renders the data graphic after the full receiving and converting.
  #
  # @param {Object} portfolio Portfolio class instance.
  # @param {Integer} symbolCount Count of checked symbols (from portfolio#show action).
  # @param {Function} callback Callback.
  initializeFetchDone: (portfolio, symbolCount, callback) ->
    converted = []

    (data) =>
      console.log 'DATA FETCHED'
      data.forEach (element) => converted.push( @appScope.ConvertYFAPIDataToHistory(element) )

      # NOTICE: symbolCount*2 <--- cuz we wanna load data in a period of 2 years,
      #         whe have to use *2 operation. Its important cuz the final sum of converted data
      #         can be recevied by two requests only (one request per one yeaer).
      #         One request - one converted data - one year.
      #         Two requests - two covnerted data - two years => two collections of symbol count.
      if converted.length is symbolCount*2
        stackedData = {}

        # Stack separated histories to the one history (stackedData)
        converted.forEach (element) ->
          for date of element
            stackedData[date] = {} if stackedData[date] is undefined
            _.extend(stackedData[date], element[date])

        # Generate portfolio's history, based on received history and portfolio's stocks
        history = portfolio.getCostHistory(stackedData)
        console.log 'HIST FORMIRATED'

        # Draw a chart
        ###############################################
        # TODO: move drawChart invokation into callback
        # TODO: SOLIDize this ugly code (for example, use #portfolio-chart as a function parameter)

        if _.isEmpty(history)
          $('#portfolio-chart').html('
            <div style="display: inline-block; text-align: center; font-size: 14px; font-weight: bold;">
              <i class="material-icons" style="vertical-align: middle">error</i> UNSUPPORTED SYMBOLS
            </div>
          ')
        else
          @appScope.drawChart(history, '#portfolio-chart')

        console.log 'GRAPHICZ GENERATED'
        ###############################################

        callback(true) if $.isFunction(callback)
      else
        callback(false) if $.isFunction(callback)

  # Datafetch fails handler
  #
  # @param {Function} callback
  initializeFetchFail: (callback) =>
    (data) ->
      console.log 'FETCH FAILED'
      callback() if $.isFunction(callback)

  # Graphics generator (will draw a graphics data after the data fetching ( from Yahoo Finance ))
  #
  # @param {Array} symbols Array of checked symbols (received from portfolio#show view (from symbol table)).
  generateGraphics: (symbols) =>
    queryGenerators = this.initializeQueryGenerators(symbols)
    portfolio       = this.initializePortfolio()
    fetchDone       = this.initializeFetchDone(portfolio, symbols.length)
    fetchFail       = this.initializeFetchFail()

    fetcher = new @appScope.YFAPIDataFetcher

    queryGenerators.forEach (QG) ->
      fetcher.setQueryGenerator(QG)
      fetcher.fetchData(fetchDone, fetchFail)

  bindThemAll: (gon, chartGenButtonSelector, showStockFormSelector) ->
    # make toast if we have a flash
    @viewCallbacks.generateToast gon
  
    # bind chart generating to the appropriate button
    $(chartGenButtonSelector).click =>
      @viewCallbacks.clickForGraphiczGenerating this.generateGraphics

    # bind stock form visible toggling to the appropriate button
    $(showStockFormSelector).click =>
      @viewCallbacks.stockFormToggle()

window.app.ApplicationFacade = ApplicationFacade